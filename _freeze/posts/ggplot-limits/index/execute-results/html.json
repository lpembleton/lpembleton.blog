{
  "hash": "e8120a66c5e7a8545cc96cd4072a92eb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Know your limits\"\ndescription: \"A brief walkthrough the consequences of different limits functions in ggplot2\"\nauthor: \"LW Pembleton\"\ndate: 10 06 2024\ncategories: [R, Visualisation, ggplot2]\nimage: images/jessica-ruscello--GUyf8ZCTHM-unsplash.jpg\ndraft: false\nhighlight-style: ayu\n---\n\n\n![~Photo by [Jessica Ruscello](https://unsplash.com/@jruscello) on Unsplash~](images/jessica-ruscello--GUyf8ZCTHM-unsplash.jpg)\n\nI recently went down a bit of an educational rabbit 🐇 hole with ggplot is setting axis limits. So I thought I would share some insights I gathered along the way.\n\nIt all started with a simple barplot 📊 using ggplot2. Typically, I prefer to filterthe data before plotting, avoiding axis limits. However, on this occasion, I wanted to focus in on the differences between values that were relatively small compared to the overall bars. Queue example data 👇\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\ndata_tbl <- tibble(sample = c(\"SampleA\", \n                              \"SampleB\", \n                              \"SampleC\", \n                              \"SampleD\", \n                              \"SampleE\"),\n                   value = c(20, \n                             20.5, \n                             22,\n                             19.8,\n                             21))\n\nggplot(data = data_tbl, aes(x = sample, y = value)) +\n  geom_bar(stat = \"identity\") +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nNaturally I went for the generically name ylim() ggplot2 function to try and focus in more on the \"tops\" of the bars.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = data_tbl, aes(x = sample, y = value)) +\n  geom_bar(stat = \"identity\") +\n  theme_bw() +\n  ylim(15, 25)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nAnd boom! 💥 Everything disappeared. Initially, I was puzzled 🤔 Where did my bars go? After some digging, I realised that ylim() was not the function I was looking for.\n\n![](images/8t4viq.jpg)\n\nThe ylim() function removes 🧹 any data outside the specified range. Since I chose a barplot, the bars extend from 0 on the y-axis to the sample value, resulting in them being removed. If I had used geom_point, everything would have been fine:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = data_tbl, aes(x = sample, y = value)) +\n  geom_point() +\n  theme_bw() +\n  ylim(15, 25)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nSo, how do I achieve the desired outcome with geom_bar? The answer is to zoom rather than limit the data, and that's where coord_cartesian() comes in:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = data_tbl, aes(x = sample, y = value)) +\n  geom_bar(stat = \"identity\") +\n  theme_bw() +\n  coord_cartesian(ylim=c(15,25))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\nUsing coord_cartesian, all the underlying data is retained, but the plot is zoomed in as if using a magnifying glass. 🔍 ✅\n\nNow, you might think this is only relevant for bar plots. However, let's explore why it's important even for scatter plots with geom_point.\n\nConsider data with a strong linear correlation. What happens when we limit the x-axis? Instead of just showing a zoomed-in focus, the linear regression is recalculated with only the data in view, resulting in a misleading correlation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\ndata(penguins)\n\nggplot(data = penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE, color = \"gray50\") +\n  theme_bw()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot(data = penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE, color = \"gray50\") +\n  theme_bw() +\n  xlim(170, 200)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-2.png){width=672}\n:::\n:::\n\n\nYou can see that depending on the context this approach could be problematic.\n\nOr, let's say you're inspecting time series data, such as growth over time:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrowth_tbl <- tibble(days = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 20, 30, 40, 50),\n                      weight = c(2, 5, 4, 7, 10, 13, 17, 17, 15, 13, 20, 25, 45, 90, 200, 500, 2000))\n\nggplot(data = growth_tbl, aes(x = days, y = weight)) +\n  geom_point() +\n  geom_line() + \n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nAnd you wanted to focus in on early growth. If you used `xlim()` instead of `coor_cartesian()`, you will notice below that the last piece of informative data, that the growth recovers and continues to increase, is lost.\n\n**xlim()**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = growth_tbl, aes(x = days, y = weight)) +\n  geom_point() +\n  geom_line() +\n  xlim(0,10) +\n  ylim(0,20) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n**coor_cartesian()**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = growth_tbl, aes(x = days, y = weight)) +\n  geom_point() +\n  geom_line() +\n  coord_cartesian(xlim=c(0,10), ylim=c(0,20)) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nWhile most statistics are computed before plotting, and therefore this may not drastically change data interpretation, using `coord_cartesian()` ensures you're zooming in rather than trimming data.\n\nMaybe you have already been through this journey and are an axis limiting champion. Hopefully though this post helps someone.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}