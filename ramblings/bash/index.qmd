---
title: "Bash"
description: "A collection of short Bash commands and tricks that individually are too short for a blog post"
author: "LW Pembleton"
date-modified: last-modified
categories: [Bash]
image: images/_a7965f42-c1c9-4377-9b76-8c681ffa6bf5.jpg
draft: false
highlight-style: ayu
toc: true
---

![](images/_a7965f42-c1c9-4377-9b76-8c681ffa6bf5.jpg)

## Using {tee} to log command outputs.

When working in a Bash terminal and you want to log the output of a command for future reference, the tee command is a handy tool, especially in multi step analyses. Here's a quick tip on how to use it effectively:

**Basic Usage:** To log the output of a command and simultaneously view it on the terminal, use the following format:

``` bash
my_command | tee my_log.txt
```

Replace `my_command` with your actual command and `my_log.txt` with the desired log file name.

**Appending to Existing Logs:** To append output to an existing log file (useful for logging multiple command or runs of the same command), use the `-a` option with `tee`:

``` bash
my_command | tee -a my_existing_log.txt
```

Capture standard error aswell: By default `tee` captures standard out (stdout) and saves it to file whilst also printing to screen. However if you want to capture standard error (stderr) as well as stdout just add `2>&1` after your command before you pipe to `tee`:

``` bash
my_command 2>&1 | tee my_log.txt
```

## Using {basename} in Bash for File Name Extraction

In Bash, you can use the `basename` command to extract the file name from a given file path. This is particularly useful when you're working on tasks like data processing pipelines or automation scripts and need to isolate the file's name from its full path.

Basic Syntax:

``` bash
basename [PATH]
```

Usage Example: Suppose you have the following file path: /path/to/your/file.txt. Using the basename command as follows:

``` bash
basename /path/to/your/file.txt
```

You will obtain just the file name `file.txt` as output:

If you also want to remove the trailing suffix simply add the suffix as a second argument to the end of the command:

``` bash
basename file.txt .txt
```

Which in this example will return `file`

## Streamling File Transfer via a Bastion Host

![](images/bastion.png)

Accessing private servers through a bastion host, like AWS private cloud, and transferring local files doesn't have to be a complex process. With a straightforward command utilising **`scp`** and the **`ProxyJump`** feature, you can seamlessly accomplish this task. Assuming your SSH keys are configured correctly on your local machine, here's how to automate the transfer to the endpoint private server via the public-facing bastion host.

``` bash
scp -J <user-name>@<Public-IPv4-DNS> \
    <file-to-transfer> \
    <user-name>@<IP-address>:/path/for/remote/file
```

For systems where **`ProxyJump`** isn't available, you can opt for the **`ProxyCommand`** method instead.

``` bash
scp -o 'ProxyCommand ssh <user-name>@<Public-IPv4-DNS> -W %h:%p' \
  <file-to-transfer> \
  <user-name>@<IP-address>:/path/for/remote/file
```

::: callout-note
It's worth noting that while both methods facilitate the transfer, **`ProxyJump`** is recommended over **`ProxyCommand`** as it adds an extra layer of encryption to the traffic, enhancing security during file transfers.
:::

## Extract Data Lines From a VCF File

![](images/vcffileformat.png)

Visual inspection üîç of the data lines (i.e. genotype fields) of VCF file is often impeded ‚õî by the large number of meta-information lines at the top. A simple sed command that looks for the mandatory body header line can get your past this hurdle üöß

``` bash
sed -n '/#CHROM/,$p' filename.vcf
```

In short this command searches for the pattern '#CHROM' and then starts printing to the screen until the end of the file. Pipe this into a head command (`| head`) and you now have a quick and simple way üü¢ to inspect the start of a VCF file.

## Separate columns in file with multiple whitespaces

When dealing with tabular text files where columns are inconsistently separated by varying numbers of whitespaces, a quick solution comes through using the translate command `tr` and the `-s` squeeze repeats feature. By employing `tr` to convert multiple consecutive whitespaces into a single whitespace, you can seamlessly tidy üßπ the data before applying `cut` for column extraction.

For instance, to isolate the 3rd and 4th columns from a file:

``` bash
tr -s ' ' < file.txt | cut -d ' ' -f 2,3
#  ^^^                            ^^^^^^
#   |                                |
#   |                                |
# squeeze repeats            get 2nd & 3rd field
```

## Human-readable file and directory sizes

Want human readable file sizes in your ls commands? Simply add `- ld`

``` bash
# Size in bytes
ls -l

# Human readable sizes
ls -h 
```

Same principle applies to directory sizes with the `du` disk usage command

``` bash
# List directory sizes 1 level deep
du -hd1

# List the total size of the current directory
du -hs
```

## Quickly search your bash history for a previous command

Say goodbye to pressing {{< kbd ‚ñ≤ >}} endlessly in bash to get back to a previously used command. Instead your can press {{< kbd Ctrl >}} + {{< kbd R >}} and search for any matching text in your previous command history. Keep pressing {{< kbd Ctrl >}} + {{< kbd R >}} to cycle through more matches.

üí° Think ahead and if there is a command you will likely need to run again, tag it with a comment `#` that your can then easily search for. For instance say you have a specific command you know you will want to run again later, append `#cmd for later` after the command. That way, you have a unique {{< kbd Ctrl >}} + {{< kbd R >}} search phrase for quicker retrieval.
